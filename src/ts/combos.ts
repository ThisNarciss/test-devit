// Це завдання було найскладнішим для мене, витратив декілька годин на нього, перебрав багато інформації
export const combos = (num: number) => {
  // Створюємо масив в який будемо пушити наші масиви з комбінаціями
  const result: number[][] = [];
  // Створюємо функцію яка буде знаходити всі унікальні комбінації що в сумі дають нам число яке заходить як параметр. Вона приймає 3 параметри:
  // 1 - це масив в який записувати комбінацію
  // 2 - це число яке контролює коли комбінація зібрана(на кожній рекурсії ми його збільшуємо і кожен раз порівнюємо з вхідним параметром num) і вже можна додавати її до головного масиву
  // 3 - число з якого починаються комбінації. На кожній ітерації воно буде збільшуватися на одиницю, а при рекурсії залишатиметься таким як на поточній ітерації
  const createCombination = (
    combination: number[],
    currentSum: number,
    start: number
  ) => {
    //   Перевірка чи ми дійшли до кінця комбінації, якщо так то додаємо комбінацію до головного масиву
    if (currentSum === num) {
      result.push([...combination]);
      return;
    }
    // Перевірка якщо контрольне число більше за вхідний аргумент то виходимо з функції
    if (currentSum > num) {
      return;
    }
    // Запускаємо цикл
    for (let i = start; i <= num; i += 1) {
      // Додаємо початкове число до комбінації
      combination.push(i);
      //  Запускаємо рекурсію в якій збільшуємо контрольне число при кожній рекурсії, передаємо масив з комбінацією, та початкове число поточної ітерації. Далі ми отримаємо декілька рекурсій поки контрольне число не зрівняється з вхідним параметром функції тоді комбінація буде зібрана і потрапить в головний масив, потім функції знімаються з call stack і з комбінації шляхом методу pop видаляються числа, доки ми не повернемося в ту ітерацію де умова ще виконується там видалиться ще одне число і ми перейдемо в наступну ітерацію. Якщо ми повертаємося до циклу де ще виконується умова переходимо до наступної ітерації та знову додаємо число до комбінації яка залишилася і так поки знову не сформується нова комбінація. Все це буде відбуватися поки перший цикл буде виконувати свою умову і його ітерації не закінчаться.
      //   Надіюся пояснив нормально, бо над цією частиною Я грався дуже довго
      createCombination(combination, currentSum + i, i);
      combination.pop();
    }
  };

  createCombination([], 0, 1);
  // Повертаємо результат із усіма комбінаціями
  return result;
};

console.log(combos(3));
// Output:
// [[3], [1, 1, 1], [1, 2]];

console.log(combos(10));
// Output:
// [
//   [10],
//   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
//   [1, 1, 1, 1, 1, 1, 1, 1, 2],
//   [1, 1, 1, 1, 1, 1, 1, 3],
//   [1, 1, 1, 1, 1, 1, 4],
//   [1, 1, 1, 1, 1, 5],
//   [1, 1, 1, 1, 6],
//   [1, 1, 1, 7],
//   [1, 1, 8],
//   [1, 9],
//   [1, 1, 1, 1, 1, 1, 2, 2],
//   [1, 1, 1, 1, 1, 2, 3],
//   [1, 1, 1, 1, 2, 4],
//   [1, 1, 1, 1, 2, 2, 2],
//   [1, 1, 1, 1, 3, 3],
//   [1, 1, 1, 2, 5],
//   [1, 1, 1, 2, 2, 3],
//   [1, 1, 1, 3, 4],
//   [1, 1, 2, 6],
//   [1, 1, 2, 2, 4],
//   [1, 1, 2, 2, 2, 2],
//   [1, 1, 2, 3, 3],
//   [1, 1, 3, 5],
//   [1, 1, 4, 4],
//   [1, 2, 7],
//   [1, 2, 2, 5],
//   [1, 2, 2, 2, 3],
//   [1, 2, 3, 4],
//   [1, 3, 6],
//   [1, 3, 3, 3],
//   [1, 4, 5],
//   [2, 8],
//   [2, 2, 6],
//   [2, 2, 2, 4],
//   [2, 2, 2, 2, 2],
//   [2, 2, 3, 3],
//   [2, 3, 5],
//   [2, 4, 4],
//   [3, 7],
//   [3, 3, 4],
//   [4, 6],
//   [5, 5],
// ];
